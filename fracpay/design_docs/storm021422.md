```
blairmunroakusa@0637.021422.anch.AK:goldcouch
```

### This is me writing about all the thinking I've done in the past day

OK.

So I've been struggling with how to construct the security model. So far it looks like this:

payfract will have access to all accounts, and anybody will have to ability to request to interact with payfract. In every case, payfract will ask for a fingerprint. This will be an encrypted public key and a four digit pin (bumpseed). Before anything, payfract client will check to see if the fingerprint works as a seed for any pdas. If so, it will return only one, and this is the operators payfract main account.

At this point, the client can get the operator ID to confirm. To do so it generates the operator self account from (opmainaddr + fingerprint + 0).

Then, the client can read how many pieces main has, and generate pieceaddr for those.

What if I want to tip a piece that I don't own though??

Piece ref pdas are generated from the piece address + number. Piece address is given, published on whatever piece it represents. Piece address, like above is generated by the piece's operator main + fingerprint + number.

How do I protect against people spoofing my piece?

It's up to the person tipping to make sure they trust the piece account they are contributing to.

What is to keep a bad actor from bypassing the client and draining accounts due to failed transaction fees? Keep in mind that the one address payfract will derive and check will be the operator id

The fees have to come from somewhere first. All the client does is make sure opmain has enough funds to cover basic fees for admin stuff. Otherwise, fees need to be extracted from contributions. Perhaps I need to figure out what the minimum contributions should be to account for fees.

So I think the contribution flow should go like this:

1 - verify user is an operator

2 - if so, get operator id and confirm

TO TIP

read pieceID and piececount from given account pubkey

verify pieceID match

determine amount to distribute

~ for # in piececount

. get ref # target, fract, flags, type

. get piecerefID from target

. get disco flag

. send [operatormain, pieceaddr, refaddr, target]
       [fingerprint, bump, fract, disco]

... validate fingerprint

... apply propagation to ref #

... log 

~ end


.
.

NEED CHECK FINGERPRINT ONCHAIN

NEED CHECK IN = 0 BEFORE MAKING CHANGES / PULLING FUNDS

.

.

.

Wallet adaption / connection:

If no signing wallet, get wallet pubkey, still connect, but generate new keypair, and use prikey as fingerprint..

If operator wishes to transfer funds to wallet, operator just provides fingerprint from personal store.

If signing wallet, connect wallet, then sign pubkey as message. This is fingerprint.

Any time operator wishes to do something on payfract, they just sign pubkey again to verify account ownership.

I want to use the fingerprint method so that even people without a formal wallet can use payfract. These people will only have a keypair for an account, say stored in a text file (sure, I mean a 'formal wallet', not an actual wallet). These people can generate their own fingerprint with openssl. a fingerprint pubkey match will authorize payfract to do anything with funds in a given main account.







Okay, just verified, ed22519 signature = sign(msg, prikey), 64B

Define, 'fingerprint' = sign(pub, pri) + pin that bumps sig pda off curve

... damn, transaction size is a huge limiting factor if we cannot derive addresses on chain.

Yeah, we're going to have to call one payfract session per reference, from the client.

Maybe in future we could setup a cronjob to trigger global payfract propagation, but for now, it's gotta be on demand.


Just stick to using wallets that sign dammit. Fuck too  complicated. NVM? Not many wallets have message signing...

New strategy ... choose ANY wallet, and link with adapter. Then open PGP encrypt wallet pubkey + operatorID + password to create fingerprint.

NONONONONOONO

Choose any wallet. Link. On client side, get password + wallet pubkey, generate new pubkey from seed, this is the fingerprint.

Generate account address from fingerprint. If payfract account already exists, throw error and get modified password.

To validate, send fingerprint with bumpseed to payfract for payfract to derive address and check it matches account pubkey. This way, payfract won't do anything unless it is dealing with 


